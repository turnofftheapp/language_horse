<h1> Test </h1>

<!-- Record RTC Library CDN -->
    <script src="https://www.WebRTC-Experiment.com/RecordRTC.js"></script>


<script>
    // RecordRTC
var recordRTC = null;

var isMimeTypeSupported = (_mimeType) => {
    // if (webrtcDetectedBrowser === 'edge')  return false;

    if (typeof MediaRecorder.isTypeSupported !== 'function') {
        return true;
    }

    return MediaRecorder.isTypeSupported(_mimeType);
};

var mimeType = 'audio/wav';
var recorderType = StereoAudioRecorder;

//if(isMimeTypeSupported(mimeType) === false) {
//    console.log(mimeType, 'is not supported.');
//    mimeType = 'audio/ogg';
//
//    if(isMimeTypeSupported(mimeType) === false) {
//        console.log(mimeType, 'is not supported.');
//        mimeType = 'audio/webm';
//    }
//}

const rtcSession = {
    type: 'audio',
    mimeType: mimeType,
    recorderType: recorderType,
    audio: true,
    video: false,
    sampleRate: 16000
};

console.log('final rtcSession object', rtcSession);

navigator.getUserMedia(rtcSession, (mediaStream) => {
    // RecordRTC requires "second" parameter named as "options" or "configuration" or "hints"
    recordRTC = RecordRTC(mediaStream, rtcSession);

    recordRTC.startRecording();

    // after X amount of seconds clear the timer interval and stop recording 
    setTimeout(() => {
        clearAndStop(recordRTC);
    }, 6000);
}, () => {
    console.error('An error has occurred while attempting to get user media.');
});

// stop recording function & clear timer
var clearAndStop = (recordRTC) => {
    recordRTC.stopRecording((blob) => {
        const recordRTCBlob = recordRTC.getBlob();
        console.log(recordRTCBlob);
    });
};
</script>